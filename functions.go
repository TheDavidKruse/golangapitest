package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"regexp"
	"strings"
)

//Most structs generated by JSON-TO-GO

type patient struct {
	ID                    int           `json:"id"`
	FirstName             string        `json:"first_name"`
	LastName              string        `json:"last_name"`
	Gender                string        `json:"gender"`
	PhoneNumber           string        `json:"phone_number"`
	Email                 string        `json:"email"`
	Address               string        `json:"address"`
	VisitDate             string        `json:"visit_date"`
	Diagnosis             string        `json:"diagnosis"`
	DrugCode              string        `json:"drug_code"`
	AdditionalInformation []information `json:"additional_information"`
}

type information struct {
	Notes      string `json:"notes"`
	NewPatient bool   `json:"new_patient"`
	Race       string `json:"race"`
	SSN        string `json:"ssn"`
}

// I dont know if this struct is even useful but I'm keeping it just in case

type patientIDs struct {
	IDs []int `json:"patient_ids"`
}

func readPatientsFromJSON() ([]patient, error) {
	jsonFile, err := os.Open("MOCK_DATA.json")
	if err != nil {
		return nil, err
	}

	fmt.Println("Successfully opened json file!")

	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var patients []patient

	json.Unmarshal(byteValue, &patients)

	return patients, nil
}

//Seperating this one out from where I had it initially because its used in multiple function calls

func savePatientsToJSON(patientArr []patient) error {
	patientJSON, err := json.Marshal(patientArr)

	if err != nil {
		return err
	}

	err = ioutil.WriteFile("MOCK_DATA.json", patientJSON, 0644)

	if err != nil {
		return err
	}

	return nil
}

func getSinglePatient(patientID int) (patient, error) {
	patients, err := readPatientsFromJSON()
	if err != nil {
		return patient{}, err
	}

	for i := range patients {
		if patients[i].ID == patientID {
			return patients[i], nil
		}
	}

	return patient{}, errors.New("Patient does not exist")
}

func (p *patient) createNewPatientInJSON() error {
	patients, err := readPatientsFromJSON()
	if err != nil {
		return err
	}
	p.ID = len(patients) + 1

	patients = append(patients, *p)

	savePatientsToJSON(patients)

	return nil
}

func searchForPatientsMatching(key, value string) (patientIDs, error) {
	/*
	 * This function in particular was a pain in the BUTT! Parsing out the string
	 * parameters took a lot of time after using the reflect package! Although it was
	 * tough I hope it's at least somewhat decent in structure.
	 */
	patients, err := readPatientsFromJSON()
	if err != nil {
		return patientIDs{}, err
	}

	var filteredPatients patientIDs

	for _, patient := range patients {

		/*
		 * for the real magic, look at the getField func!
		 * It's just taking a patient and a key (key of the querystring parameter)
		 * and returning the value to be used in a comparison with the value of the
		 * querystring parameter value
		 */

		fieldValue := getField(patient, key)

		if fieldValue == value {
			filteredPatients.IDs = append(filteredPatients.IDs, patient.ID)
			fmt.Printf("found one")
		}
	}

	if filteredPatients.IDs == nil {
		return patientIDs{}, errors.New("hello")
	}
	return filteredPatients, nil
}

func getField(p patient, fieldName string) string {

	// Get the value of the patient struct, we need the tags for later filtering
	patientStructTags := reflect.ValueOf(p)

	// Create the regex formula to parse out the special characters of the querystrig key
	reg, _ := regexp.Compile("[^a-zA-Z0-9]+")

	// Apply regex
	parsedTagName := reg.ReplaceAllString(fieldName, "")

	// Loop over the patient struct tags
	for i := 0; i < patientStructTags.Type().NumField(); i++ {

		// Set the name of the struct field to compare to the regex parsed querystring parameter
		tag := patientStructTags.Type().Field(i).Name

		// If the struct tag and the regex parsed querystring tag are equal, send the key value from the struct where the key is the struct key
		if strings.ToLower(tag) == parsedTagName {
			return strings.ToLower(reflect.Indirect(patientStructTags).FieldByName(tag).String())
		}
	}

	// if nothing else, send an empty string
	return ""

}

func updatePatientInJSON(updatePatient patient, index int) error {
	patients, _ := readPatientsFromJSON()

	for i := range patients {
		if patients[i].ID == index {
			patients[i] = updatePatient
		}
	}

	savePatientsToJSON(patients)
	return nil
}
